Stencil is another buffer, that looks like the depth buffer, but for each pixel we don't store the depth but we store a value that can be between 0 and 255.
The stencil test is executed after the fragment shader, and its goal is like the depth test to discard some fragments to make the next steps in the rendering pipeline faster.
Stencil buffer is a bit crazy, we update it however we want during rendering, but it looks like this generally:
- Enable writing to the stencil buffer
- Draw object 1 and update stencil buffer using it
- Disable writing to stencil buffer
- Draw object 2 but while discarding some fragments from stencil testing.
----------------------------------
Sure, let's assume that the 3x3 matrix represents the pixels of an image, and you want to draw the middle pixel. Here's how the stencil buffer would look at each iteration:

1. **Initial state**: The stencil buffer is cleared to 0.

    ```
    0 0 0
    0 0 0
    0 0 0
    ```

2. **After rendering the model (middle pixel)**: The stencil function is set to always pass, and the reference value is set to 1. So, when you render the middle pixel (the model), the stencil buffer is updated with the reference value at the corresponding position.

    ```
    0 0 0
    0 1 0
    0 0 0
    ```

3. **After rendering the border**: The stencil function is set to pass when the stencil buffer value is not equal to 1. So, when you render the border, the stencil buffer is not updated (because writing to the stencil buffer is disabled), but the border is only drawn where the stencil buffer value is not 1.

    The stencil buffer still looks like this:

    ```
    0 0 0
    0 1 0
    0 0 0
    ```

    But the image looks like this (B represents the border, M represents the model):

    ```
    B B B
    B M B
    B B B
    ```

4. **Final state**: The stencil function is reset to always pass, and the stencil mask is reset to allow writing to the stencil buffer. The stencil buffer still looks the same, but you can now render other objects, and the stencil buffer will be updated according to the stencil function and mask.

    ```
    0 0 0
    0 1 0
    0 0 0
    ```

This is a simplified example, but it should give you a good idea of how the stencil buffer works. In a real application, the stencil buffer would be the same size as the window, and you would use the stencil buffer to control the rendering of complex 3D models.
----------------------------------
Sure, here's a step-by-step breakdown of the OpenGL function calls and the state of the stencil buffer:

1. **Enable stencil testing and set up the stencil operation**:

    ```c
    glEnable(GL_STENCIL_TEST);
    glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);
    ```

    Initial stencil buffer:

    ```
    0 0 0
    0 0 0
    0 0 0
    ```

2. **Set the stencil function to always pass and render the model (middle pixel)**:

    ```c
    glStencilFunc(GL_ALWAYS, 1, 0xFF);
    glStencilMask(0xFF);
    // Render the model here
    ```

    Stencil buffer after rendering the model:

    ```
    0 0 0
    0 1 0
    0 0 0
    ```

3. **Change the stencil function to pass when the stencil buffer value is not equal to 1, disable writing to the stencil buffer, disable the depth test, and render the border**:

    ```c
    glStencilFunc(GL_NOTEQUAL, 1, 0xFF);
    glStencilMask(0x00);
    glDisable(GL_DEPTH_TEST);
    // Render the border here
    ```

    Stencil buffer after rendering the border (it remains the same because writing to the stencil buffer is disabled):

    ```
    0 0 0
    0 1 0
    0 0 0
    ```

4. **Reset the stencil function and mask, and re-enable depth testing**:

    ```c
    glStencilMask(0xFF);
    glStencilFunc(GL_ALWAYS, 0, 0xFF);
    glEnable(GL_DEPTH_TEST);
    ```

    Final stencil buffer (it remains the same because no more rendering is done):

    ```
    0 0 0
    0 1 0
    0 0 0
    ```