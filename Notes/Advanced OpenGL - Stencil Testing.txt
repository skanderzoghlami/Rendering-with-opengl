Stencil is another buffer, that looks like the depth buffer, but for each pixel we don't store the depth but we store a value that can be between 0 and 255.
The stencil test is executed after the fragment shader, and its goal is like the depth test to discard some fragments to make the next steps in the rendering pipeline faster.
Stencil buffer is a bit crazy, we update it however we want during rendering, but it looks like this generally:
- Enable writing to the stencil buffer
- Draw object 1 and update stencil buffer using it
- Disable writing to stencil buffer
- Draw object 2 but while discarding some fragments from stencil testing.
----------------------------------
Sure, let's assume that the 3x3 matrix represents the pixels of an image, and you want to draw the middle pixel. Here's how the stencil buffer would look at each iteration:

1. **Initial state**: The stencil buffer is cleared to 0.

    ```
    0 0 0
    0 0 0
    0 0 0
    ```

2. **After rendering the model (middle pixel)**: The stencil function is set to always pass, and the reference value is set to 1. So, when you render the middle pixel (the model), the stencil buffer is updated with the reference value at the corresponding position.

    ```
    0 0 0
    0 1 0
    0 0 0
    ```

3. **After rendering the border**: The stencil function is set to pass when the stencil buffer value is not equal to 1. So, when you render the border, the stencil buffer is not updated (because writing to the stencil buffer is disabled), but the border is only drawn where the stencil buffer value is not 1.

    The stencil buffer still looks like this:

    ```
    0 0 0
    0 1 0
    0 0 0
    ```

    But the image looks like this (B represents the border, M represents the model):

    ```
    B B B
    B M B
    B B B
    ```

4. **Final state**: The stencil function is reset to always pass, and the stencil mask is reset to allow writing to the stencil buffer. The stencil buffer still looks the same, but you can now render other objects, and the stencil buffer will be updated according to the stencil function and mask.

    ```
    0 0 0
    0 1 0
    0 0 0
    ```

This is a simplified example, but it should give you a good idea of how the stencil buffer works. In a real application, the stencil buffer would be the same size as the window, and you would use the stencil buffer to control the rendering of complex 3D models.
----------------------------------
Sure, here's a step-by-step breakdown of the OpenGL function calls and the state of the stencil buffer:

1. **Enable stencil testing and set up the stencil operation**:

    ```c
    glEnable(GL_STENCIL_TEST);
    glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);
    ```

    Initial stencil buffer:

    ```
    0 0 0
    0 0 0
    0 0 0
    ```

2. **Set the stencil function to always pass and render the model (middle pixel)**:

    ```c
    glStencilFunc(GL_ALWAYS, 1, 0xFF);
    glStencilMask(0xFF);
    // Render the model here
    ```

    Stencil buffer after rendering the model:

    ```
    0 0 0
    0 1 0
    0 0 0
    ```

3. **Change the stencil function to pass when the stencil buffer value is not equal to 1, disable writing to the stencil buffer, disable the depth test, and render the border**:

    ```c
    glStencilFunc(GL_NOTEQUAL, 1, 0xFF);
    glStencilMask(0x00);
    glDisable(GL_DEPTH_TEST);
    // Render the border here
    ```

    Stencil buffer after rendering the border (it remains the same because writing to the stencil buffer is disabled):

    ```
    0 0 0
    0 1 0
    0 0 0
    ```

4. **Reset the stencil function and mask, and re-enable depth testing**:

    ```c
    glStencilMask(0xFF);
    glStencilFunc(GL_ALWAYS, 0, 0xFF);
    glEnable(GL_DEPTH_TEST);
    ```

    Final stencil buffer (it remains the same because no more rendering is done):

    ```
    0 0 0
    0 1 0
    0 0 0
    ```


WHY WE NEED ALL THIS (STENCIL/DEPTH TESTING)
so we executed the very expansive fragment shader on all fragments, then we discarded some of them thanks to depth/stencil testing, now what do we win ? which operations that were so expansive are now no longer eecuted 

After the fragment shader has been executed and the depth/stencil testing has discarded some fragments, you've essentially saved on the following operations:

1. **Color Blending**: If a fragment is discarded, the GPU doesn't need to perform blending operations with the existing color in the framebuffer. Blending involves reading the current color from the framebuffer, combining it with the new color, and then writing the result back to the framebuffer. This can be a costly operation, especially in scenes with a lot of overdraw.

2. **Framebuffer Writes**: Writing the final color of a fragment to the framebuffer is a memory operation that can be quite expensive, especially at high resolutions where there are many pixels. By discarding fragments early, you reduce the number of these operations.

3. **Bandwidth**: Both of the above operations involve memory transfers, which consume bandwidth. By reducing the number of fragments that need to be processed, you can reduce the overall memory bandwidth usage, which can be a significant performance gain on hardware where bandwidth is a limiting factor.

So, while the fragment shader is still executed for all fragments, depth and stencil testing can help to reduce the overall workload on the GPU by eliminating unnecessary work for fragments that won't contribute to the final image.